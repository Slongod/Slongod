---
title: SNOI前 做题记录
date: 2023-11-27 09:08:17
tags: 做题记录
secret: 密码
description: SNOI前 做题记录，包含一些 洛谷省选计划 的题。
---

# SNOI前 做题记录

## T402404 星辰

对于一个排列 $P$，它的逆排列 $P'$ 满足 $P'{p_i}=i$，显然，对合排列的逆排列为其本身。

对于原排列 $P$ 中的任意一组逆序对 $(i,j),(p_i,p_j)$，满足 $i<j,p_i>p_j$，其在 $P'$ 中唯一对应一组逆序对 $(p_j,p_i),(j,i)$。则我们可以对于所有的逆序对为 $k$ 的排列，同时删除当前存在的所有**非对合排列**，同时保证数量奇偶性不变。因此，**逆序对个数为 $k$ 的对合排列的奇偶性，就是逆序对个位数为 $k$ 的排列的奇偶性**。

{% raw %}

考虑 DP，枚举填了 $t$ 个数，令 $f_{k}$ 表示考虑前 $t$ 个数（$1,2,\dots t$），现在有 $k$ 个逆序对的方案数，则由于 $t>t-1>\dots>1$，所以枚举 $t$ 的位置，可得：
$$
f_{k}=\sum_{i=k-t+1}^{k}f_{i}
$$
记 $m=\frac{n(n-1)}{2}$，直接 DP 是 $O(n^2m)$ 的。进行前缀和优化为 $O(nm)$。

考虑第 $t$ 轮转移，实际上是先进行前缀和 $f_i=f_{i-1}+f_{i}$，然后令 $f_i=f_{i}-f_{i-t}$。考虑 $f$ 的生成函数 $F$，则实际上是：

$$
F_t=(\sum_{i=0}^{\infty}x_i)(1-x^{t})F_{t-1}=\frac{1}{1-x}(1-x^{t})F_{t-1}
$$
边界为 $F_0=1$，则：
$$
F_n=\prod_{t=1}^{n}\frac{1}{1-x}(1-x^{t})\\
=\frac{1}{(1-x)^n}\prod_{t=1}^{n}(1-x^{t})\\
=(\sum_{i=0}{{n+i-1}\choose{i}}x_i)\prod_{t=1}^{n}(1-x^t)
$$
考虑卢卡斯定理：

$$
{n\choose{m}}\pmod{p}\equiv {\lfloor\frac{n}{p}\rfloor\choose{\lfloor\frac{m}{p}\rfloor}}{n\operatorname{mod} p\choose{m \operatorname{mod} p}}\pmod{p}
$$
则对于 $p=2$，${{n}\choose{m}} \equiv 1 \pmod{p}$ 当且仅当 $n\&m=m$，即 $n$ 的二进制表示是 $m$ 的超集。

于是可以快速计算出  $\sum_{i=0}{{n+i-1}\choose{i}}x_i$，对于后面的乘积，由于答案对 $2$ 取模，可以用 $\text{bitset}$ 优化。

{% endraw %}

时间复杂度为 $O(\frac{nm}{w})$。

--------------------------------------------

## CF1883G2 Dances (Hard Version)

答辩题面，看了好久才懂。虽然之前好像嘴过（

当 $a_1$ 不变的时候，显然可以二分出答案。

考虑 $a_1$ 的变化对答案的影响，当 $a_1$ 很小的时候，答案与 $a_1=1$ 的时候相同。当 $a_1=1$ 时候的答案不合法的时候，只要多删一个就能合法，因此，总的答案段数只有至多两段，且答案分别为 $ans(a_1=1),ans(a_1=1)+1$。

二分出这个分界点，每次 $check$ 的时候再套一层二分就行了，时间复杂度 $O(n\log n\log m)$。 

----------------------------------------------------

## CF1344D Résumé Review

记 $f(i,x)=x(a_i-x^2),g(i,x)=f(i,x+1)-f(i,x)$。

考虑暴力的做法，先令所有的 $b_i=0$，然后每次贪心地在满足 $b_i<a_i$ 的 $i$ 中选择 $g(i,b_i)$ 最大的 $i$，令 $b_i+1$，然后就做完了。但是时间复杂度为 $O(k \log n)$ $\tiny \color{red} 过 \color{black} 不 \color{purple}去$，所以我们需要优化计算的过程。

$f(i,x)$ 这个东西显然是个凸的，所以 $g(i,x)$ 是单调不升的。考虑我们选择的最后一个 $i$，记 $t=g(i,b_i -1)$，一定有 $\forall j\in[1,n], g(j,b_j) \le t$。又因为 $g(i,x)$ 单调，所以 $t$ 越大，$\sum b_i$ 越小，反之亦然。

这样我们就可以二分 $t$ 了。对于每一个二分出来的 $mid$，我们对于每个 $i$ 找出最小的 $b_i$ 使得 $g(i,b_i)\le t$，这也可以用另一个二分得到。然后我们判断 $\sum b_i$ 和 $k$ 的关系，若 $\sum b_i > k$ 说明 $t >mid$，否则说明 $t\le mid$。

还有一个细节，由于我们选择是的最小的 $b_i$，所以最终的 $\sum b_i$ 可能小于 $k$，需要调整。这时候我们就可以再选择一些满足 $g(i,b_i)=t$ 的 $i$ 令 $b_i+1$。由于我们二分出的是满足 $\sum b_i <= k$ 的最小 $t$，这样调整一定能够使得 $\sum b_i = k$。

二分的边界开大点，$1e18$ 都不够，我开的 $1e30$ 才过。

-----------------------------------

## P8150 再会 | Sayounara

感觉不如原神。

如果我们能知道最小值和位置的话，我们就可以用 $n$ 次询问获得所有 $a_i$。记 $p_{min}$ 是最小值的位置，对于 $i>p_{min}$，我们可以知道 $\sum_{j=p_{min}+1}^{i} a_j$，然后差分一下就行，$i<p_{min}$ 同理。

现在我们只需要知道最小值的位置了。用心感受一下，发现在 $300$ 次以内找到可以得满分，于是我们大胆猜测需要三分。

考虑对于 $lm , rm(lm<rm)$，我们记 $gl = \text{query}(1,rm)-\text{query}(1,lm-1)，gr=\text{query}(lm,r)-\text{query}(rm+1,r)$，最小值为 $minval$，则：

- 若最小值在 $[lm,rm]$ 中，则 $gl=\sum_{i=lm}^{rm}a_i-minval-\min_{i=1}^{lm-1}a_i,gr=\sum_{i=lm}^{rm}a_i-minval-\min_{i=rm+1}^{n}a_i$，由于所有的 $a_i$ 不相等，因此 $gl\not =gr$。
- 若最小值在 $[1,lm)$ 中，则 $gl=\sum_{i=lm}^{rm} a_i,gr=\sum_{i=lm}^{rm}a_i$ 或 $gr=\sum_{i=lm}^{rm}a_i-\min_{i=lm}^{rm}a_i-\min_{i=rm+1}^{n}a_i$（取决于 $\min_{i=lm}^{n} a_i$ 的位置）。比较一下可以得到 $gl\le gr$。
- 若最小值在 $(rm,n]$ 中，同上可得 $gl \ge gr$。

因此我们每次可以将区间大小至少缩小 $\lfloor\frac{len}{3}\rfloor$，最后剩下 $1,2$ 个的时候直接 $\text{get}$ 即可。

------------------------------------

## [ARC016D] 軍艦ゲーム

设 $f_{u,k}$ 表示从 $u$ 这个点出发，当前 HP 是 $k$，到达 $n$ 的期望时间，记 $deg_i$ 是 $i$ 的个数，$u\rightarrow v$ 表示存在一条边 $(u,v)$。直接 DP 是简单的：


$$
\left \{
    \begin{array}{l}  
    & f_{u,v}=\infty \quad && (j\le 0)\\
    & f_{u,j}=\frac{1}{deg_u}\sum_{u\rightarrow v} f_{v,j-d_v}+1 \quad && (u=1,j>0)\\
    & f_{u,j}=\min\{\frac{1}{deg_u}\sum_{u\rightarrow v} f_{v,j-d_v}+1,f_{1,H}+H-j\} \quad && (u\not =1,u\not = n,j>0)\\
    & f_{u,j}=0 \quad && (u = n,j>0)\\
    \end{array}  
\right.
$$
我们要求的就是 $f_{1,H}$，但是这个式子直接算的话会出现环。

**难以发现**，我们先假定 $f_{1,H}=A$，记 $g(A)$ 为此时计算出的 $f_{1,H}$，我们就需要找到一个 $A=g(A)$ 的 $A$，这就是我们的答案。记 $h(A)=g(A)-A$，则 $h(A)$ 单调不升，证明可以看一下[题解 AT771 軍艦ゲーム - iMya_nlgau 的博客](https://www.luogu.com.cn/blog/Mly2019/solution-at771)。

于是我们直接二分 $A$ 就行了，时间复杂度是 $O(nH\log V)$。

-------------------------------

## LRCOI#4 Genshin

只会有一个人抢过来，否则第一个抢过来的人肯定不会抢。因此，当且仅当不会有别人抢过去的时候当前的人才会抢过来。

考虑二分图博弈（[算法学习笔记: 二分图博弈](https://zhuanlan.zhihu.com/p/359334008)），发现会发生被抢的事情，当且仅当初始点为 $X$ 的时候，二分图博弈的先手必胜。于是跑一遍网络流就能知道能否被抢了。

怎么输出方案呢？发现抢的那个人一定是和 $X$ 匹配的编号最小的点，而两个点能匹配当且仅当它们之间的边可以作为最大匹配的一条匹配边。我们跑完 Dinic 后，一条边能在最大匹配中当且仅当以下两条有一条满足：

1. 若两个点之间的边流了流量，则一定是一条匹配边。
2. 若两个点之间的边没有流流量，则只考虑残量网络上还有流量的边，若两个点在同一个强联通分量，则这个点可以作为最大匹配的一条匹配边。

上述第二条的原理如下：

想把非匹配边 $(u_0,v_0)$ 当做匹配边，需要找到一条路径 $\{u_0,v_0,u_1,v_1,\dots v_{k-1},u_k\}$，其中 $u$ 是左部点， $v$ 是右部点，$(u_i,v_i)$ 是非匹配边，$(u_{i+1},v_i)$ 是匹配边，容易证明这样的路径一定满足：只考虑残量网络上还有流量的边，一定存在一条路径 $\{u_0\rightarrow v_0\rightarrow u_1 \rightarrow \dots \rightarrow u_k \rightarrow s \rightarrow u_0\}$，其中 $s$ 是源点。

然后就做完了。~~我才不会告诉你我 Tarjan 写挂了 3 次。~~

--------------------------------

## P9144 [THUPC 2023 初赛] 最后的活动

同 **[ARC016D] 軍艦ゲーム** ，发现 DP 式子有环，然后二分就行。另外，对于 $g(A)-A$ 随 $A$ 的增长递减，这件事的另一种感性理解是 $g(A)$ 比 $A$ 更靠近真实答案。这道题要注意精度，由于值都很小，所以判断 $a>b$ 不要写 $a-b>eps$，而是直接写 $a-b>0$。

-----------------------

## P4219 [BJOI2014] 大融合

精神上理解了 ETT。

考虑离线下来然后树剖，但是可能是个森林，所以建立一个超级源点就行了。时间复杂度 $O(n\log^2n)$，不需要脑子。

想起来了在 [洛谷日报](https://www.luogu.com.cn/blog/dyf-DYF/euler-tour-tree-xue-xi-bi-ji) 上看见的伪 ETT，可以维护子树信息，挺好，写一下吧。

------------------------------------------------

## P7706 「Wdsr-2.7」文文的摄影布置

线段树上直接维护一些东西就行了。

一些东西：

- 最大 $a$。
- 最小 $b$。
- $a$ 在左边的时候的 $a-b$ 的最大值。
- $a$ 在右边的时候的 $a-b$ 的最大值。
- 最大答案。

---------------------------

## P6617 查找 Search

记 $pre_i$ 是 $w-a_i$ 上一次出现的位置，不存在则 $pre_i=0$，则询问就是在问 $\max_{i=l}^{r}\{pre_i\}$ 是否大于等于 $l$。直接维护的话是 $O(n^2)$ 的，没有优化空间。

$\color{purple}\huge{\text{难以发现}}$，我们可以将 $pre$ 的定义更换，同时保持答案不受影响。记 $p$ 是 $a_i$ 上一次出现的位置，若当前 $a_i$ 第一次出现则 $p=0$。记 $q$ 是上文说的 $pre_i$，新的 $pre$ 定义如下：

$$
pre_i=
\left \{
    \begin{array}{l}
    	& q && q\ge p\\
    	& 0 && q < p\\
    \end{array}
\right.
$$
容易证明，这样定义不影响我们上文对答案的转换。

这样就好维护多了，每次将 $x$ 更改为 $y$ 的时候只需要更改以下位置的 $pre$ 值：

- 当前位置。
- 下一个 $w-x$ 的位置。
- 下一个 $x$ 的位置。
- 下一个 $w-y$ 的位置。
- 下一个 $y$ 的位置。

然后用 $\text{set}$ 维护所有值的位置，同时用线段树维护一下 $pre$ 和区间最大值就行了，时间复杂度 $O(n\log n)$。

----------------

## P4139 上帝与集合的正确用法

考虑扩展欧拉定理：
$$
a^x\equiv a^{x\operatorname{mod} \phi(p)+\phi(p)} \pmod{p}
$$
记 $t=2^{2^{2^{2^{\dots}}}}$，则：
$$
t\operatorname{mod} p=
\left\{
	\begin{array}{l}
		&0 && p=1\\
		& 2 ^ {t\operatorname{mod}\phi(p)+\phi(p)} &&p>1
	\end{array}
\right.
$$
由于：
$$
\left\{
    \begin{array}{l}
    	& 2|\phi(p) && p>1\\
    	& \phi(p)<\frac{p}{2} && 2|p
    \end{array}
\right.
$$


于是上式直接计算就行了，使用线性筛，时间复杂度为 $O(P+T\log P)$。

-------------

## P3747 [六省联考 2017] 相逢是问候

依托答辩。

同上题（**P4139 上帝与集合的正确用法**），发现每个位置只会被修改 $\log$ 次，于是先算出最大的修改次数，每次对于还能被修改的暴力到叶子修改就行了。

考虑修改，记：

$$
\left\{
    \begin{array}{l}
        f(x,k,p)=\huge c^{c^{\dots(共k个c)^{a_i}}} \large \pmod{p}\\
        f(x,k)=\huge c^{c^{\dots(共k个c)^{a_i}}}\\
    \end{array}
\right.
$$
则：
$$
f(x,k,p)=
\left\{
    \begin{array}{l}
    	&0 &&p=1\\
    	&x &&k=0\\
    	&c^{f(x,k-1,\phi(p))+[f(x,k-1)\ge\phi(p)]\times \phi(p)} &&otherwise.
    \end{array}
\right.
$$
于是计算的时候顺便返回一下 $f(x,k)$ 是否大于 $p$ 即可。在每一层 $f(x,k,p)$ 里面用快速幂，单次计算是 $O(\log^2P)$ 的，总的时间复杂度是 $O(n(\log n+\log P)\log^2P)$不能通过，发现只有 $O(\log P)$ 层，即只有这么多模数，于是预处理一下光速幂，同时记录下是否大于等于模数就可以了。光速幂可以见 [快速幂 2 LibreOJ](https://loj.ac/p/162)。

-------------------------------

## P1471 方差

线段树上维护一下 $\sum a_i^2$ 和 $\sum a_i$ 就行了。

----------------------

## CF444C DZY Loves Colors

分块。

修改：

- 对于颜色数大于 $1$ 的块，或者修改的边缘的散块，直接暴力重构。因为最多有 $n+m$ 种颜色，因此算上散块也最多重构 $O(n+m)$ 次。
- 对于只有一种颜色的块打 $\text{tag}$。
- 时间复杂度 $O((n+m)(B+\frac{n}{B}))$

查询：

- 对于散块，直接下放 $\text{tag}$ 然后查询。
- 对于中间的块，每个块维护一个 $sum$ 表示每一个块中的权值和，直接查询。
- 时间复杂度 $O(m(B+\frac{n}{B}))$。

$B$ 取 $\sqrt{n}$ 最优，复杂度 $O((n+m)\sqrt{n})$。

--------------

## T404283 三元组统计（triple）

记 $a_{i,j}=a_i-a_j,b,c$ 同理，则题目让计算这个东西：
$$
\sum_{i=1}^n\sum_{j=i+1}^n\max(a_{i,j},b_{i,j},c_{i,j})-\min(a_{i,j},b_{i,j},c_{i,j})\\
= \frac{1}{2}\sum_{i,j\le n,i\not=j}\max(a_{i,j},b_{i,j},c_{i,j})-\min(a_{i,j},b_{i,j},c_{i,j})\\
$$
容易发现，$\max(a,b,c)-\min(a,b,c)=\frac{\max(a,b)-\min(a,b)+\max(a,c)-\min(a,c)+\max(b,c)-\min(b,c)}{2}$，即 最大值+最大值+次大值-最小值-最小值-次小值，等于 最大值+最大值-最小值-最小值。

于是我们只需要计算若干个形如 $\sum_{i,j\le n,i\not=j} \max(a_i-a_j,b_i-b_j)-\min(a_i-a_j,b_i-b_j)$ 的式子。

再次容易发现，当 $a_i-b_i > a_j-b_j$ 的时候，上式等于 $a_i-a_j-b_i+b_j=(a_i-b_i)-(a_j-b_j)$。即 $a_i-b_i$ 的贡献的系数为 $1$ 当且仅当 $a_i-b_i>a_j-b_j$，否则贡献系数为 $-1$。于是将所有的 $a_i-b_i$ 从小到大排序后，第 $i$ 个位置的贡献为 $(i-1-(n-i))=(2i-n-1)$。

时间复杂度 $O(n\log n)$。

-------------------

## MXOI-20231205-A 做题掉坑（[CF Gym104012I](https://codeforces.com/gym/104012/problem/I)）

首先缩掉所有的段，然后转一下将会寄的那一个放在最后一个。接着转化一下，记 $f_i$ 是进行了 $i$ 次操作还没有寄寄的概率，发现寄掉的期望步数 $=\sum_{i=0}f_i$，理由如下：

- 在第 $i$ 次寄掉的概率是 $f_{i-1}-f_i$，而 $\sum_{i=0}f_i=\sum_{i=1} i(f_{i-1}-f_i)$ ，即寄掉的期望步数。

然后这样还是不好算，考虑计算进行 $i$ 次操作还没有寄寄的方案数 $g_i$，则 $f_i=\frac{g_i}{n^i}$。

{% raw %}

设 $G_{i,j}$ 为考虑从第 $i$ 个到第 $m$ 个，选了 $j$ 次还没有寄的方案数，$a_i$ 表示第 $i$ 段的位置数，则：
$$
G_{i,j}=\sum_{k=0}a_i^kG_{i+1,j-k}{{j}\choose{k}}\\
\frac{G_{i,j}}{j!}=\sum_{k=0}\frac{a_{i}^{k}}{k!}\frac{G_{i+1,j-k}}{(j-k)!}
$$
然后是 LRC 快乐时间，考虑 EGF，记 $H_k(x)=\sum_{i=0}^{m-k}\frac{a_k^ix^i}{i!}$，从后往前卷一下就行了，但是注意乘到第 $m-i$ 段的时候，最多选 $i$ 次不会寄奇，所以卷完要把不合法的项的系数赋成 $0$。

记上文卷出来的那个东西是 $O=\sum_{i=0}\frac{o_i}{i!}x^i$，则答案是 $\sum_{i=0}\frac{o_i}{n^i}$。

{% endraw %}

------------------------------

## P8352 [SDOI/SXOI2022] 小 N 的独立集

好 VAN 的 DP 套 DP 题，是 [大哥](https://www.luogu.com.cn/user/1024338) 喜欢的类型。

### 一：超级暴力

最简单的方法就是暴力枚举每个点的权值，然后 DP，设 $g_{u,0/1}$ 分别表示强制不选/不强制不选 $u$ 的时候，$u$ 子树内的最大权独立集，这样单次时间复杂度 $O(n)$，总时间复杂度是 $O(k^nn)$，显然直接原地螺旋爆炸。

### 二：DP 套 DP

DP 套 DP，个人理解就是将内层的 DP 融入进入外层 DP 的下标，比如这道题，可以设 $f_{u,v_0,v_1}$ 表示考虑 $u$ 的子树，$g_{u,0}=v_0,g_{u,1}=v_1$ 时候的方案数，初始为 $f_{u,0,i}=1(1\le i\le k)$。考虑 $x$ 的一个儿子 $y$ 的时候，记 $h_{v0,v1}$ 是不考虑 $y$ 的时候的 $f_{x,v0,v1}$，则转移如下：
$$
f_{x,p0+\max(o0,o1),p1+o0}\leftarrow f_{y,o0,o1}\times h_{p0,p1}
$$
时间复杂度 $O(n^3k^4)$。

### 三：优化 DP 套 DP

考虑上述的 $v0$ 和 $v1$ 一定满足 $v1\ge v0$，且 $v1-v0\le k$，理由显然。于是可以把第三维缩掉，用 $f_{u,p0,p1}$ 表示 $v0=p0,v1=p0+p1$ 时候的方案数。转移如下：
$$
f_{x,p0+o0+o1,\max(p0+o0+o1,p0+p1+o0)}\leftarrow f_{v,o0,o1}\times h_{p0,p1}
$$
时间复杂度 $O(n^2 k^4)$，优化一下常数，就会非常不满，可以通过。

------------------

## P9361 [ICPC2022 Xi'an R] Contests

首先，我们简记为有 $m$ 行，每行一个 $n$ 的排列。其次，答案显然不超过 $n-1$。

发现跳的时候，对于第 $i$ 行一定会跳到最靠前的位置，这样显然是最优的。考虑倍增，记 $f_{k,u,i}$ 表示 $u$ 这个数，跳了至多 $2^k$ 次的时候，在第 $i$ 行的最靠前的位置是什么。预处理是 $O(nm^2\log n)$ 的。

询问的时候倍增就可以了，如果跳 $2^k$ 步的时候，每一行都没有在 $y$ 前面，就让 $x$ 跳这么多步。每次跳是 $O(m^2)$ 的，复杂度 $O(qm^2\log n)$。

别忘了最后统计答案的时候，如果当前的所有位置里面没有 $y$，需要给答案加 $1$（再跳一步）。

感觉贴代码比较适合：

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Slongod{
const int N = 1e5+7 , M = 6 , MX = 18;
int n , m , q , a[M][N] , pos[N][M] , cache[M] , f[MX][N][M];
bool check(int x[] , int y[])
{
    for (int i = 1; i <= m; i++) {
        if (x[i] <= y[i]) {
            return 1;
        }
    } return 0;
}
void init()
{
    memset(f , 0x3f , sizeof(f));
    for (int i = 1; i <= m; i++) {
        memset(cache , 0x3f , sizeof(cache));
        for (int j = n; j >= 1; j--) {
            for (int k = 1; k <= m; k++) {
                cache[k] = min(cache[k] , pos[a[i][j]][k]);
                f[0][a[i][j]][k] = min(f[0][a[i][j]][k] , cache[k]);
            }
        }
    }
    for (int o = 1; o < MX; o++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                for (int k = 1; k <= m; k++) {
                    f[o][i][k] = min(f[o][i][k] , f[o-1][a[j][f[o-1][i][j]]][k]);
                }
            }
        }
    }
}
void move(int x[] , int k)
{
    int tmp[M]; memcpy(tmp , x , sizeof(int[M]));
    memset(x , 0x3f , sizeof(int[M]));
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= m; j++) {
            x[j] = min(x[j] , f[k][a[i][tmp[i]]][j]);
        }
    }
}
bool try_move(int x[] , int y[] , int k)
{
    int tmp[M]; memcpy(tmp , x , sizeof(int[M])); move(x , k);
    if (check(x , y)) {
        memcpy(x , tmp , sizeof(int[M]));
        return 0;
    } else {
        return 1;
    }
}
void main()
{
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> a[i][j]; pos[a[i][j]][i] = j;
        }　
    } init();
    cin >> q;
    for (int _i = 1 , x , y , res; _i <= q; _i++) {
        cin >> x >> y; res = 0;
        int now[M]; memcpy(now , pos[x] , sizeof(now));
        if (check(now , pos[y])) {
            cout << 1 << '\n';
        } else {
            for (int i = MX-1; i >= 0; i--) {
                if (try_move(now , pos[y] , i)) {
                    res += (1<<i);
                }
            }
            move(now , 0); res += 2;
            for (int i = 1; i <= m; i++){if (now[i] == pos[y][i]){res--; break;}}
            cout << (res <= n ? res : -1) << '\n';
        }
    }
}
}int main()
{
    ios :: sync_with_stdio(0);
    cin.tie(0) , cout.tie(0);
    return Slongod :: main(),0;
}
```

----------

## P8594 「KDOI-02」一个仇的复

{% raw %}

考虑只用 $y$ 个**横着放的矩形**将 $x$ 列的 $2\times x$ 方格，分成 $j$ 个部分（不能有一个矩形同时存在于任意两个不同的部分）并填满的方案数：
$$
g(x,y,j)={x-1\choose j-1}{2x-2k\choose y-2k}
$$
第一项即枚举每一段的开始位置（第一段一定是 $1$ ，不用枚举），第二项即枚举每一个不是当前段的开始列的矩形的起始位置。

回到题目来计算答案，枚举有几个竖着放的 $2\times 1$ 矩形，再枚举有几个竖着的矩形之间的间隔为空，则答案是：
$$
\sum_{i=0}^{k}\sum_{j=0}^{i}{i+1\choose j}g(n-i,k-i,i+1-j)
$$
时间复杂度 $O(V+k^2)$，取模一定要取干净。

{% endraw %}

--------------

## P1861 星之器

挺好的题，以前没见过。

玩一下样例，容易发现，所有移动的方案最后的答案都是一样的，于是我们只需要找一种简单计算答案的方式。

每一维对答案的贡献都是考虑设一个势能函数来计算，使得移动的势能差等于对答案的贡献，即：
$$
\begin{array}{l}
&f(x+1)+f(y-1)-f(x)-f(y)=y-x-1 &&(x>y)
\end{array}
$$
记 $z=y-1$，可以得到：
$$
f(x)-f(x+1)+x=f(z)-f(z+1)+z
$$
于是我们只需要使得对于任意的 $x$，令 $f(x)-f(x+1)+x$ 为定值就行了。

设 $f(x)=ax^2+bx+c$，可以解得上式等于 $(1-2a)x^2-a-b$，于是我们令 $a=\frac{1}{2}$ 就行了，为了除 $2$ 还是整数，可以令 $f(x)=\frac{x(x-1)}{2}+802x+923$。

然后用初始的势能和减去最终的势能和就是我们的答案。

------------------------

## MXOI-20231205-B 攀比之心([CF Gym 102431G]())

不如原神。

假设已经选出来了一棵包含 $1$ 的树，若 $1$ 在直径的中点上，则无论先手选什么点，后手每一次均能选出一个点 $x$，使得 $x$ 离 $1$ 的距离和 $1$ 离当前点的距离相等，后手必胜；若 $1$ 不在直径的中点上，则相当于后手先动了一下，于是先手必胜。

所以现在要计算所有包含 $1$，且 $1$ 在直径中点上的联通块。设 $mx_u$ 为 $u$ 子树中离 $u$ 最远的点到 $u$ 的距离，$f_{u,k}$ 表示考虑 $u$ 的子树，最远点离 $u$ 为 $k$ 的联通块的方案数，则 $f_{u,0}=1$。长链剖分一下，每次从最深的儿子处继承，然后考虑合并新的儿子。记 $tmp_k$ 为不含新的儿子的 $f_{u,k}$，转移如下：
$$
f_{u,k}=tmp_k+tmp_k\sum_{j=0}^{k-1} f_{v,j}+\sum_{j=0}^{k-1}tmp_jf_{v,k-1}
$$
直接转移是 $O(n^3)$ 的，前缀和优化是 $O(n^2)$ 的（因为要枚举长链的长度次，所以长链剖分如剖）。容易发现每次只枚举短链的长度，因为对于 $k>mx_v+1$ 的 $k$，从 $v$ 合并的贡献都是一样的，所以打个 $tag$ 然后维护一下，时间复杂度是 $O(n)$ 的。

在根处统计答案，设 $g_{0/1,k}$ 表示有选出了 $1$ 个/多个 子树离 $1$ 最远点为 $k$ 的联通块的方案数，初始 $h_{1,0}=1$，考虑合并子树 $v$，记 $tmp_{0/1,k}$ 为不含新的儿子的 $g_{0/1,k}$，转移如下：
$$
g_{1,k}=tmp_{1,k}+tmp_{1,k}\sum_{j=0}^{k-1}f_{v,j}+tmp_{0,k}f_{v,k-1}\\
g_{0,k}=tmp_{0,k}+tmp_{0,k}\sum_{j=0}^{k-2}f_{v,j}+\sum_{j=0}^{k-1}(tmp_{0,j}+tmp_{1,j})f_{v,k-1}
$$
同样维护一些 $tag$ 就行了。然后就做完了，最后的答案是 $\sum_i g_{1,i}$，时间复杂度 $O(n)$，~~晚上再写~~（写完了，低达 4.7K）。

------------------------------------------

## CF103E Buying Sets

双倍经验：[LOJ #6045. 「雅礼集训 2017 Day8」价](https://loj.ac/p/6045)

将所有集合的权值取反，变成选最大权值，下文的所有讨论均基于此基础。

先不考虑选的集合和选的数数量相等，这就是一个朴素的最大权闭合子图问题，直接网络流，跑最小割就可以了。

为了满足数量相等的限制，我们可以给每一个集合的权值加上 $lim$，给选每一个数的代价也设为 $lim$，其中 $lim$ 是一个特别大的数。记集合 $i$ 的原权值为 $x_i$。将集合放在左部点，对于集合 $i$，连一条边 $S\rightarrow i$，权值是 $lim+x_i$；将数放在右部点，对于数 $i$，连一条边 $i\rightarrow T$，权值是 $lim$；集合和对应的点之间连边权为 $\infty$ 的边。最后割完之后，若集合/数与 $S$ 在一起，代表选，否则代表不选。由于选的集合的数量 $\le$ 选的数的数量（题目保证），即 不选的集合数量+选的数的数量 $\ge n$，所以求的最小割一定满足 不选的集合数量 $+$ 选的数的数量 $=n$，即选的集合数量 $=$ 选的数的数量。

时间复杂度为 Dinic 的复杂度，但远底于 $O(n^4)$ 的上界。

----------------

## P4764 [CERC2014] Pork barrel

以前做过。

先按边权从大到小排序，然后 LCT + 主席树。

-------------------

## CF708E Student's Camp

{% raw %}

有意思的题。关键是计算最后剩下 $[l,r]$ 的概率是：

$$
记 \enspace D(x)={k\choose x}p^x(1-p)^{k-x}\\
则 \enspace P(l,r)=D(l-1)D(m-r)
$$
然后设 $f_{i,l,r}$ 是到第 $i$ 行，$l,r$ 仍能和最上面联通的概率，边界是 $f_{0,1,m}=1$，容易得到：
$$
f_{i,l,r}=P(l,r)\sum_{[l'r']\cap [l,r] \not= \empty} f_{i-1,l',r'}
$$
直接做时间复杂度是 $O(nm^4)$ 的。

记 $S_{i,r}=\sum_{j=1}^{r} f_{i,j,r}$，$T_{i,l}=\sum_{j=l}^{m}f_{i,l,j}$，容易发现 $S_{i,j}=T_{i,m-j+1}$。

记 $F_{i}=\sum_{l\le r} f_{i,l,r} , SS(i,l,r)=\sum_{k=l}^{r}S_{i,k},ST(i,l,r)=\sum_{k=l}^{r}T_{i,k}$，则：
$$
f_{i,l,r}=F_{i-1}-\sum_{j=1}^{l-1}S_{i-1,j}-\sum_{j=r+1}^{m}T_{i-1,j}\\
=F_{i-1}-SS(i-1,1,l-1)-ST(i-1,r+1,m)
$$


状态还是太多了，即使 $O(1)$ 转移时间复杂度也是 $O(nm^2)$。

推一下式子：
$$
S_{i,r}=\sum_{j=1}^{r}f_{i,j,r}\\
=\sum_{j=1}^{r}P(j,r)(F_{i-1}-SS(i-1,1,j-1)-ST(i-1,r+1,m))\\
=\sum_{j=1}^{r}D(j-1)D(m-r)(F_{i-1}-SS(i-1,1,j-1)-ST(i-1,r+1,m))\\
=D(m-r)[\sum_{j=1}^{r}D(j-1)(F_{i-1}-ST(i-1,r+1,m))-\sum_{j=1}^{r}D(j-1)SS(i-1,1,j-1)]
$$
$D$ 可以预处理，且 $F_i=\sum_{j=1}^{m}S(i,j)$，我们也只需要知道 $F_n$。因此我们只需要维护一下 $D(x)$ 和 $D(j-1)SS(i-1,1,j-1)$ 的前缀和，就可以 $O(1)$ 转移了。

时间复杂度 $O(k+nm)$。

{% endraw %}

--------------------------------------------------

## AT_arc100_d [ARC100F] Colorful Sequences



LRC 给讲的好 VAN 的 DP 题，应该是 [大哥](https://www.luogu.com.cn/user/1024338) 喜欢的类型。

分三类讨论，先计算出所有序列中包含的 $A$ 的个数，然后减去不合法的。

- $A$ 中包含一个 $1$ 到 $k$ 的排列，不用减，$ans=ans$。
- $A$ 中包含重复元素，分左右两边 DP，设 $f_{i,j}$ 表示连续 $i$ 个字符，最后最多有 $j$ 个不重复的数字的方案数，初始状态视 $A$ 而定。记左右两边最后得到的答案是 $f$ 和 $g$，则 $ans=ans-\sum_{i=1}^{n-m}(\sum_{j=1}^{k-1}f_{i,j})(\sum_{j=1}^{k-1} g_{n-m-i,j})$。
- $A$ 中不包含重复元素，算出所有不包含要求的排列的序列中，任意长度为 $m$ 的不重复的序列的出现次数，记这个数字为 $sum$，{% raw %}则 $ans=ans-\frac{sum}{{k\choose m}m!}$。{% endraw %}

--------------

## P1393 Mivik 的标题

ACC 讲的 字符串+DP 题，被 LRC 用 GF 秒了。

设 $f_i$ 表示长度为 $i$ 的串，且 $S$ 第一次出现的位置是 $[i-|S|+1,i]$ 的串的个数。则 $ans=\sum_{i=1}^{n}f_im^{n-i}$。

先令 $f_i=m^{i-|S|}$，显然这样会算重，需要减去重复的数量。记实际上第一次出现的串是 $S'$，重复的情况有以下两种：

### 一：

$S'$ 上一次出现的位置在 $i-|S|$ 之前，即 $S'$ 和 $S$ 不重合，则这部分的数量为 $\sum_{j=1}^{i-|S|-1}f_{j}m^{i-|S|-1-j}$，DP 的时候顺便维护一下即可。

### 二：

难点在于 $S'$ 和 $S$ 有重合的部分。对于这部分，显然重叠的部分是 $S$ 的一个 $border$，所以这部分的数量为 $\sum_{S[1,l]=S[len-l+1,len]}{f_{i-|S|+l}}$。然而，直接跑一遍 kmp 然后暴力枚举所有 $border$ 的时间复杂度为 $O(n^2)$，不能通过。
引理：

> 对于 S 的所有 $border$，其长度构成 $O(log|S|)$ 个不交的等差数列

所以我们就可以维护 $O(log|S|)$ 个等差数列的和，减去的时候只需要跳 $O(log|S|)$ 次，时间复杂度就是 $O(n\log|S|)$，可以通过。

----------------------------

## P5609 [Ynoi2013] 对数据结构的爱 && CF1172F Nauuo and Bug

线段树，每一个节点维护 $c_x$ 表示最小的 $k$，使得 $k$ 经过当前节点（从左往右）后减去了 $x\times p$ 。由于每个节点最多能减去 $rt-lt+1$ 个 $p$，所以线段树里总共只有 $O(n\log n)$ 个 $c$（每一层 $n$ 个）。

考虑怎么 $pushup$，记 $ls,rs$ 为左右儿子，$len$ 为线段树节点维护的区间长度，$sum$ 为线段树节点维护的区间和，则最朴素的想法就是：
$$
c_x=\min(\sum_{i=0}^{len_{ls}}\sum_{j=0}^{len_{rs}}[c_{ls,i+1}-1+sum_{ls}-ip\ge c_{rs,j}]\max(c_{ls,i},c_{rs,j}-sum_{ls}+ip))
$$
其中：

- 前面的取 $\min$ 是 $c$ 的定义。

- 方括号内的表示这次合并合法，即左儿子减去 $ip$ 的最大 $k$，能够在经过左儿子的区间后还满足右儿子减去 $jp$ 的条件。
- 后面的取 $\max$ 代表左右儿子的条件都能够满足。

直接 $pushup$ 显然是 $O(len_{ls}len_{rs})$ 的，不能接受。根据 $c$ 的定义，我们发现 $c_i+sum_i-ip=0$，因此 $c_{i}-c_{i-1}\ge p$ 。设 $f(i,j)=\max(c_{ls,i},c_{rs,j}-sum_{ls}+ip)$，因为 $c_{ls,i+1}-1+sum_{ls}-ip\ge c_{rs,j}$，所以 $c_{rs,j}-sum_{ls}+ip\lt c_{ls,i+1}$，即 $f(i,j)<f(i+1,j-1)$。所以对于一个 $i$，将其能够向当前节点贡献的最小、最大 $j$ 记作 $\min_ij ,\max_i j$，则 $\max_{i}j\le \min_{i+1}j$，因此直接双指针即可，时间复杂度 $O(len)$。

查询的时候，对于 $O(\log n)$ 个节点依次二分出需要减去的 $p$ 的数量即可。

总时间复杂度 $O(n\log n+m\log^2 n)$。

----

## P1829 [国家集训队] Crash的数字表格 / JZPTAB && P3911 最小公倍数之和 && AT_agc038_c [AGC038C] LCMs

归结为计算 $\sum_{i=1}^{n}\sum_{j=1}^{m}\operatorname{lcm}(a_i,b_j)$，其中 $a,b$ 是两个长度分别为 $n,m$ 的序列。

记 $V$ 是 $a,b$ 的值域，VAN 一下柿子。
$$
\sum_{i=1}^{n}\sum_{j=1}^{m}\operatorname{lcm}(a_i,b_j)\\
=\sum_{i=1}^{n}\sum_{j=1}^{m}\frac{a_ib_j}{\gcd(a_i,b_j)}\\
=\sum_{d=1}^{V}\frac{1}{d}\sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(a_i,b_j)=d]a_ib_j
$$
我们令
$$
f(d)=\sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(a_i,b_j)=d]a_ib_j\\
g(d)=\sum_{i=1}^{n}\sum_{j=1}^{m}[d|\gcd(a_i,b_j)]a_ib_j
$$
则
$$
g(d)=\sum_{d|x}f(x)
$$
所以我们得知了 $g(d)$ 就可以用狄利克雷前缀和 $O(V\log\log V)$ 地计算出 $f(d)$。考虑如何计算 $g(d)$，显然有
$$
g(d)=(\sum_{d|a_i}a_i)(\sum_{d|b_i}b_i)
$$
两个括号内的式子也都可以用狄利克雷前缀和求出。

最后我们再带入最开始的式子：
$$
ans=\sum_{d=1}^{V}\frac{1}{d}f(d)
$$
然后做完了，如果取模可以在线性筛的时候顺便求出 $\forall i,i^{-1}\pmod {p}$，其中 $p$ 是要对其取模的质数。

时间复杂度 $O(V\log\log V)$。

-----------

## P5404 [CTS2019] 重复

ACC 讲的 串串题。出现一次好像不太好算，我们可以反着来，算出 $t^\infty$ 的所有子串都大于 $s$ 的 $t$ 的数量，再用总数量减去。

考虑建出 $s$ 的 $\text{kmp}$ 自动机，则若当前匹配到了 $u$，记 $u$ 的原始出边为 $s_u$，令 $mx_u=\max(mx_{fail_u},s_u)$，则下一步走的边 $u \overset{w}{\rightarrow} v$ 应该满足 $w\ge mx_u$，因此，我们可以将小于 $mx_u$ 的所有边删去，得到一个新的自动机，下文的所有讨论均基于这个新的自动机。

若 $T^\infty$ 最后会匹配到了自动机上的 $u$，其含义是 $T^\infty$ 的最长的后缀，使得其与 $s$ 的相同长度的前缀相等。由于 $T^\infty+T=T^\infty$ ，即两者的任意后缀相等，所以 $T^\infty+T$ 最后也会匹配到 $u$，即任意 $T$ 重复若干次之后，一定会走入 $s$ 中的唯一的一个长为 $m$ 的环。

$s$ 中的一个长为 $m$ 的环唯一对应的字符串也一定是一个合法的 $T$，不会存在从头开始匹配走不过来的情况。我们假设 $T^\infty$ 不能匹配到 $u$ 而 $S+T^\infty$ 能够匹配到 $u$，其中 $S$ 是一个我们钦定的字符串，因为 $T^\infty$ 无限长，所以当前匹配的最长后缀与 $S$ 没有关系，所以 $T^\infty$ 也能匹配到 $u$，假设不成立。

所以我们只需要统计从自动机里面的任意点 $u$ 出发，经过一个长度为 $m$ 的环后回到 $u$ 的环的数量即可。

根据 $mx_u$ 的定义，我们可以发现，想要不经过根，只能一直沿着 $mx_u$ 走。因为长度只有 $m$，所以我们可以对于每个点暴力走，最后判断是否走回了 $u$ 即可。

对于经过根的那些环，我们可以枚举走了 $i$ 步之后走到了根，然后就只需要知道从根走 $m-i$ 步走到 $u$ 的方案数即可。

设 $f_{i,j}$ 表示从根走 $i$ 步走到 $j$ 的方案数，则：
$$
f_{i,j}\underset{\exist edge(j,k)}{\rightarrow} f_{i+1,k}
$$
总时间复杂度 $O(nm)$。

LRC 本题的代码 CE 了，因为被我加了一个全角空格（坏笑.jpg）

----------------------

# 这一周没有题解
因为这一个星期生病了（疑似是流感，而且我还【数据删除】，【数据删除】石【数据删除】华，不过我从来没说过“我是【数据删除】”这句话）。![](https://pic.imgdb.cn/item/654d99a6c458853aefd1ad77.gif)

-------------------

- CF1194F Crossword Expert
- CF1901D Yet Another Monster Fight
- P5368 [PKUSC2018] 真实排名
- P3706 [SDOI2017] 硬币游戏
- P5608 [Ynoi2013] 文化课
- P3181 [HAOI2016] 找相同字符
- SP2939 QTREE5 - Query on a tree V
- P6773 [NOI2020] 命运
- P8518 [IOI2021] 分糖果
- P3643 [APIO2016] 划艇
- P1674 [USACO05FEB] Secret Milking Machine G
- P2053 [SCOI2007] 修车
- P2172 [国家集训队] 部落战争
- CF671D Roads in Yusland
- CF1418G Three Occurrences
- CF710F String Set Queries
- P2424 约数和
- CF587F Duff is Mad
- P3645 [APIO2015] 雅加达的摩天楼
- CF273E Dima and Game
- [ABC327G] Many Good Tuple Problems
- P5901 [IOI2009] Regions
- CF540E Infinite Inversions
- CF1446D2 Frequency Problem (Hard Version)
- P3215 [HNOI2011] 括号修复 / [JSOI2011]括号序列

# 新的一周，新的题解！！![](https://pic.imgdb.cn/item/654d99a6c458853aefd1ad77.gif)

## T405472 矩阵计数

对于一个点，记 $val_{i,j}$ 为其上面的数，要满足两条限制：

- $val_{i,j} \le row_i,val_{i,j} \le col_j \rightarrow val_{i,j}\le \min(row_i,col_j)$。
- 每一行或每一列，至少存在一个数的值为 $row_i$ 或 $col_j$。

“对于类似的题，都可以像这一题的第一条一样，将两个或多个限制取较严格的那一个，比如 [P4229 某位歌姬的故事](https://www.luogu.com.cn/problem/P4229)。”（模拟赛讲评 by laofudasuan）

显然将 $row,col$ 两个数组排序不会影响方案数，于是我们将它们从小到大排序。称 $val_{i,j}\le x$ 为 $x$ 控制 $(i,j)$，于是某一个数控制的区域会是一个 L 型。如下图（从省选计划课程里截的，红色、蓝色、绿色、紫色分别代表 $1,2,3,4$ 控制的区域）：

![PICTURE](https://pic.imgdb.cn/item/657ff95fc458853aef5fa6a5.png)

显然每一个区域是独立的，于是我们可以对于一个区域，算出有多少种方案，最后乘起来就行了。一片区域对应的行和列是左上角的矩形对应的行和列。

直接算不好算，考虑容斥。设左上角矩形左上角的点是 $(i,j)$，这个矩形有 $x$ 行 $y$ 列，我们记 $lenx=m-j+1,leny=n-i+1$，这是每一行和每一列对应的点的数量。则整个区域的点的数量为 $sum=x\times lenx+y\times leny-x\times y$。我们钦定有 $tx$ 行 $ty$ 列不满足第二个条件，则不满足的点的数量是 $nosum(tx,ty)=tx\times lenx+ty\times leny-tx\times ty$，最终答案（这个区域的方案数）就是：
$$
\sum_{i=0}^{x}\sum_{j=0}^{y}{x\choose i}{y\choose j}p^{nosum(i,j)}(p+1)^{sum-nosum(i,j)}
$$
然后就做完了，时间复杂度 $O(Tnm)$。

----------------------

## T405474 树上逆序对问题

对于一个序列，其 $\text{正着的逆序对个数}+\text{反着的逆序对个数}=\frac{len(len-1)}{2}-\text{这个序列相同的无序对格式}$。

然后就树上莫队就行了，时间复杂度 $O(n\sqrt n)$，我才没有把块长写成了 $30$ 然后 T 飞呢。

----------------------

## T405476 背包装物品

考虑那些体积为 $1$ 的物品，对于一个体积为 $1$ 的物品：

- 若选了偶数次，则等同于体积为 $2$ 的物品。
- 若选了奇数次，则等同于先选了 $1$ 个，然后选了偶数次。

于是我们可以枚举选了多少个奇数次的体积为 $1$ 的物品，则答案为：
$$
\sum_{i=0}^{n}[2|(k-i)]{n \choose i} {k-i+n+m-1\choose n+m-1}
$$
然后卢卡斯定理就行了。

----------------------

## P3736 [HAOI2016] 字符合并

由于收益非负，所以对于一个串，一定是合并合并再合并直到不能合并为止，每次合并长度会减少 $k-1$，于是对于一个子串 $[l,r]$，其最后的长度一定是 $(r-l)\operatorname{mod} (k-1)+1$。

考虑 状压+区间 DP，我们可以设 $f_{l,r,S}$ 为子串 $[l,r]$ 最终合并成了 $S$ 的方案数，其中 $S$ 是一个长为 $(r-l)\operatorname{mod} (k-1)+1$ 的 $01$ 串，可以压成一个不超过 $2^{k-1}$ 的二进制数。

- 对于 $(r-l)\operatorname{mod}\not =0$ 的情况，我们可以枚举最右边一位是由原串中的哪个子串合并成的，由上文关于合并的长度的讨论，我们可以得出，最右边的一位对应的原串一定是 $[r,r],[r-(k-1),r],[r-2(k-1),r]\dots$。
- 对于 $(r-l)\operatorname{mod}=0$ 的情况，我们可以枚举它在长度缩成 $1$ 之前一步的情况 $t$，则 $t$ 也可以像 $(r-l)\operatorname{mod}\not =0$ 一样进行讨论，最后再加上从 $t$ 缩成一位的贡献。
- 边界是 $r=l$，此时若原串中 $l$ 的位置的数字等于 $S$，则 $f_{l,r,S}=0$，否则 $f_{l,r,S}=-\infty$。

可以记忆化搜索，那么转移就像这样：

```cpp

    if ((r - l) % (k - 1) == 0) {
        for (int t = 0; t < (1<<k); t++) {
            if (c[t] == s) {
                ll tmp = -inf;
                for (int i = r-1; i >= l; i -= k-1) {
                    tmp = max(tmp , dfs(l , i , (t>>1)) + dfs(i+1 , r , t&1));
                } fnow = max(fnow , tmp + w[t]);
            }
        }
    } else {
        for (int i = r-1; i >= l; i -= k-1) {
            fnow = max(fnow , dfs(l , i , (s>>1)) + dfs(i+1 , r , s&1));
        }
    } return fnow;
```

时间复杂度 $O(n^2\lfloor\frac{n}{k}\rfloor2^k)$。
