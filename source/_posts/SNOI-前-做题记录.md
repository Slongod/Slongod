---
title: SNOI前 做题记录
date: 2023-11-27 09:08:17
tags: 做题记录
secret: 密码
description: SNOI前 做题记录，包含一些 洛谷省选计划 的题。
---

# SNOI前 做题记录

## T402404 星辰

对于一个排列 $P$，它的逆排列 $P'$ 满足 $P'{p_i}=i$，显然，对合排列的逆排列为其本身。

对于原排列 $P$ 中的任意一组逆序对 $(i,j),(p_i,p_j)$，满足 $i<j,p_i>p_j$，其在 $P'$ 中唯一对应一组逆序对 $(p_j,p_i),(j,i)$。则我们可以对于所有的逆序对为 $k$ 的排列，同时删除当前存在的所有**非对合排列**，同时保证数量奇偶性不变。因此，**逆序对个数为 $k$ 的对合排列的奇偶性，就是逆序对个位数为 $k$ 的排列的奇偶性**。

{% raw %}

考虑 DP，枚举填了 $t$ 个数，令 $f_{k}$ 表示考虑前 $t$ 个数（$1,2,\dots t$），现在有 $k$ 个逆序对的方案数，则由于 $t>t-1>\dots>1$，所以枚举 $t$ 的位置，可得：
$$
f_{k}=\sum_{i=k-t+1}^{k}f_{i}
$$
记 $m=\frac{n(n-1)}{2}$，直接 DP 是 $O(n^2m)$ 的。进行前缀和优化为 $O(nm)$。

考虑第 $t$ 轮转移，实际上是先进行前缀和 $f_i=f_{i-1}+f_{i}$，然后令 $f_i=f_{i}-f_{i-t}$。考虑 $f$ 的生成函数 $F$，则实际上是：

$$
F_t=(\sum_{i=0}^{\infty}x_i)(1-x^{t})F_{t-1}=\frac{1}{1-x}(1-x^{t})F_{t-1}
$$
边界为 $F_0=1$，则：
$$
F_n=\prod_{t=1}^{n}\frac{1}{1-x}(1-x^{t})\\
=\frac{1}{(1-x)^n}\prod_{t=1}^{n}(1-x^{t})\\
=(\sum_{i=0}{{n+i-1}\choose{i}}x_i)\prod_{t=1}^{n}(1-x^t)
$$
考虑卢卡斯定理：

$$
{n\choose{m}}\pmod{p}\equiv {\lfloor\frac{n}{p}\rfloor\choose{\lfloor\frac{m}{p}\rfloor}}{n\operatorname{mod} p\choose{m \operatorname{mod} p}}\pmod{p}
$$
则对于 $p=2$，${{n}\choose{m}} \equiv 1 \pmod{p}$ 当且仅当 $n\&m=m$，即 $n$ 的二进制表示是 $m$ 的超集。

于是可以快速计算出  $\sum_{i=0}{{n+i-1}\choose{i}}x_i$，对于后面的乘积，由于答案对 $2$ 取模，可以用 $\text{bitset}$ 优化。

{% endraw %}

时间复杂度为 $O(\frac{nm}{w})$。

--------------------------------------------

## CF1883G2 Dances (Hard Version)

答辩题面，看了好久才懂。虽然之前好像嘴过（

当 $a_1$ 不变的时候，显然可以二分出答案。

考虑 $a_1$ 的变化对答案的影响，当 $a_1$ 很小的时候，答案与 $a_1=1$ 的时候相同。当 $a_1=1$ 时候的答案不合法的时候，只要多删一个就能合法，因此，总的答案段数只有至多两段，且答案分别为 $ans(a_1=1),ans(a_1=1)+1$。

二分出这个分界点，每次 $check$ 的时候再套一层二分就行了，时间复杂度 $O(n\log n\log m)$。 

----------------------------------------------------

## CF1344D Résumé Review

记 $f(i,x)=x(a_i-x^2),g(i,x)=f(i,x+1)-f(i,x)$。

考虑暴力的做法，先令所有的 $b_i=0$，然后每次贪心地在满足 $b_i<a_i$ 的 $i$ 中选择 $g(i,b_i)$ 最大的 $i$，令 $b_i+1$，然后就做完了。但是时间复杂度为 $O(k \log n)$ $\tiny \color{red} 过 \color{black} 不 \color{purple}去$，所以我们需要优化计算的过程。

$f(i,x)$ 这个东西显然是个凸的，所以 $g(i,x)$ 是单调不升的。考虑我们选择的最后一个 $i$，记 $t=g(i,b_i -1)$，一定有 $\forall j\in[1,n], g(j,b_j) \le t$。又因为 $g(i,x)$ 单调，所以 $t$ 越大，$\sum b_i$ 越小，反之亦然。

这样我们就可以二分 $t$ 了。对于每一个二分出来的 $mid$，我们对于每个 $i$ 找出最小的 $b_i$ 使得 $g(i,b_i)\le t$，这也可以用另一个二分得到。然后我们判断 $\sum b_i$ 和 $k$ 的关系，若 $\sum b_i > k$ 说明 $t >mid$，否则说明 $t\le mid$。

还有一个细节，由于我们选择是的最小的 $b_i$，所以最终的 $\sum b_i$ 可能小于 $k$，需要调整。这时候我们就可以再选择一些满足 $g(i,b_i)=t$ 的 $i$ 令 $b_i+1$。由于我们二分出的是满足 $\sum b_i <= k$ 的最小 $t$，这样调整一定能够使得 $\sum b_i = k$。

二分的边界开大点，$1e18$ 都不够，我开的 $1e30$ 才过。

-----------------------------------

## P8150 再会 | Sayounara

感觉不如原神。

如果我们能知道最小值和位置的话，我们就可以用 $n$ 次询问获得所有 $a_i$。记 $p_{min}$ 是最小值的位置，对于 $i>p_{min}$，我们可以知道 $\sum_{j=p_{min}+1}^{i} a_j$，然后差分一下就行，$i<p_{min}$ 同理。

现在我们只需要知道最小值的位置了。用心感受一下，发现在 $300$ 次以内找到可以得满分，于是我们大胆猜测需要三分。

考虑对于 $lm , rm(lm<rm)$，我们记 $gl = \text{query}(1,rm)-\text{query}(1,lm-1)，gr=\text{query}(lm,r)-\text{query}(rm+1,r)$，最小值为 $minval$，则：

- 若最小值在 $[lm,rm]$ 中，则 $gl=\sum_{i=lm}^{rm}a_i-minval-\min_{i=1}^{lm-1}a_i,gr=\sum_{i=lm}^{rm}a_i-minval-\min_{i=rm+1}^{n}a_i$，由于所有的 $a_i$ 不相等，因此 $gl\not =gr$。
- 若最小值在 $[1,lm)$ 中，则 $gl=\sum_{i=lm}^{rm} a_i,gr=\sum_{i=lm}^{rm}a_i$ 或 $gr=\sum_{i=lm}^{rm}a_i-\min_{i=lm}^{rm}a_i-\min_{i=rm+1}^{n}a_i$（取决于 $\min_{i=lm}^{n} a_i$ 的位置）。比较一下可以得到 $gl\le gr$。
- 若最小值在 $(rm,n]$ 中，同上可得 $gl \ge gr$。

因此我们每次可以将区间大小至少缩小 $\lfloor\frac{len}{3}\rfloor$，最后剩下 $1,2$ 个的时候直接 $\text{get}$ 即可。

------------------------------------

## [ARC016D] 軍艦ゲーム

设 $f_{u,k}$ 表示从 $u$ 这个点出发，当前 HP 是 $k$，到达 $n$ 的期望时间，记 $deg_i$ 是 $i$ 的个数，$u\rightarrow v$ 表示存在一条边 $(u,v)$。直接 DP 是简单的：


$$
\left \{
    \begin{array}{l}  
    & f_{u,v}=\infty \quad && (j\le 0)\\
    & f_{u,j}=\frac{1}{deg_u}\sum_{u\rightarrow v} f_{v,j-d_v}+1 \quad && (u=1,j>0)\\
    & f_{u,j}=\min\{\frac{1}{deg_u}\sum_{u\rightarrow v} f_{v,j-d_v}+1,f_{1,H}+H-j\} \quad && (u\not =1,u\not = n,j>0)\\
    & f_{u,j}=0 \quad && (u = n,j>0)\\
    \end{array}  
\right.
$$
我们要求的就是 $f_{1,H}$，但是这个式子直接算的话会出现环。

**难以发现**，我们先假定 $f_{1,H}=A$，记 $g(A)$ 为此时计算出的 $f_{1,H}$，我们就需要找到一个 $A=g(A)$ 的 $A$，这就是我们的答案。记 $h(A)=g(A)-A$，则 $h(A)$ 单调不升，证明可以看一下[题解 AT771 軍艦ゲーム - iMya_nlgau 的博客](https://www.luogu.com.cn/blog/Mly2019/solution-at771)。

于是我们直接二分 $A$ 就行了，时间复杂度是 $O(nH\log V)$。

-------------------------------

## LRCOI#4 Genshin

只会有一个人抢过来，否则第一个抢过来的人肯定不会抢。因此，当且仅当不会有别人抢过去的时候当前的人才会抢过来。

考虑二分图博弈（[算法学习笔记: 二分图博弈](https://zhuanlan.zhihu.com/p/359334008)），发现会发生被抢的事情，当且仅当初始点为 $X$ 的时候，二分图博弈的先手必胜。于是跑一遍网络流就能知道能否被抢了。

怎么输出方案呢？发现抢的那个人一定是和 $X$ 匹配的编号最小的点，而两个点能匹配当且仅当它们之间的边可以作为最大匹配的一条匹配边。我们跑完 Dinic 后，一条边能在最大匹配中当且仅当以下两条有一条满足：

1. 若两个点之间的边流了流量，则一定是一条匹配边。
2. 若两个点之间的边没有流流量，则只考虑残量网络上还有流量的边，若两个点在同一个强联通分量，则这个点可以作为最大匹配的一条匹配边。

上述第二条的原理如下：

想把非匹配边 $(u_0,v_0)$ 当做匹配边，需要找到一条路径 $\{u_0,v_0,u_1,v_1,\dots v_{k-1},u_k\}$，其中 $u$ 是左部点， $v$ 是右部点，$(u_i,v_i)$ 是非匹配边，$(u_{i+1},v_i)$ 是匹配边，容易证明这样的路径一定满足：只考虑残量网络上还有流量的边，一定存在一条路径 $\{u_0\rightarrow v_0\rightarrow u_1 \rightarrow \dots \rightarrow u_k \rightarrow s \rightarrow u_0\}$，其中 $s$ 是源点。

然后就做完了。~~我才不会告诉你我 Tarjan 写挂了 3 次。~~

--------------------------------

## P9144 [THUPC 2023 初赛] 最后的活动

同 **[ARC016D] 軍艦ゲーム** ，发现 DP 式子有环，然后二分就行。另外，对于 $g(A)-A$ 随 $A$ 的增长递减，这件事的另一种感性理解是 $g(A)$ 比 $A$ 更靠近真实答案。这道题要注意精度，由于值都很小，所以判断 $a>b$ 不要写 $a-b>eps$，而是直接写 $a-b>0$。

-----------------------

## P4219 [BJOI2014] 大融合

精神上理解了 ETT。

考虑离线下来然后树剖，但是可能是个森林，所以建立一个超级源点就行了。时间复杂度 $O(n\log^2n)$，不需要脑子。

想起来了在 [洛谷日报](https://www.luogu.com.cn/blog/dyf-DYF/euler-tour-tree-xue-xi-bi-ji) 上看见的伪 ETT，可以维护子树信息，挺好，写一下吧。

------------------------------------------------

## P7706 「Wdsr-2.7」文文的摄影布置

线段树上直接维护一些东西就行了。

一些东西：

- 最大 $a$。
- 最小 $b$。
- $a$ 在左边的时候的 $a-b$ 的最大值。
- $a$ 在右边的时候的 $a-b$ 的最大值。
- 最大答案。

---------------------------

## P6617 查找 Search

记 $pre_i$ 是 $w-a_i$ 上一次出现的位置，不存在则 $pre_i=0$，则询问就是在问 $\max_{i=l}^{r}\{pre_i\}$ 是否大于等于 $l$。直接维护的话是 $O(n^2)$ 的，没有优化空间。

$\color{purple}\huge{\text{难以发现}}$，我们可以将 $pre$ 的定义更换，同时保持答案不受影响。记 $p$ 是 $a_i$ 上一次出现的位置，若当前 $a_i$ 第一次出现则 $p=0$。记 $q$ 是上文说的 $pre_i$，新的 $pre$ 定义如下：

$$
pre_i=
\left \{
    \begin{array}{l}
    	& q && q\ge p\\
    	& 0 && q < p\\
    \end{array}
\right.
$$
容易证明，这样定义不影响我们上文对答案的转换。

这样就好维护多了，每次将 $x$ 更改为 $y$ 的时候只需要更改以下位置的 $pre$ 值：

- 当前位置。
- 下一个 $w-x$ 的位置。
- 下一个 $x$ 的位置。
- 下一个 $w-y$ 的位置。
- 下一个 $y$ 的位置。

然后用 $\text{set}$ 维护所有值的位置，同时用线段树维护一下 $pre$ 和区间最大值就行了，时间复杂度 $O(n\log n)$。

----------------

## P4139 上帝与集合的正确用法

考虑扩展欧拉定理：
$$
a^x\equiv a^{x\operatorname{mod} \phi(p)+\phi(p)} \pmod{p}
$$
记 $t=2^{2^{2^{2^{\dots}}}}$，则：
$$
t\operatorname{mod} p=
\left\{
	\begin{array}{l}
		&0 && p=1\\
		& 2 ^ {t\operatorname{mod}\phi(p)+\phi(p)} &&p>1
	\end{array}
\right.
$$
由于：
$$
\left\{
    \begin{array}{l}
    	& 2|\phi(p) && p>1\\
    	& \phi(p)<\frac{p}{2} && 2|p
    \end{array}
\right.
$$


于是上式直接计算就行了，使用线性筛，时间复杂度为 $O(P+T\log P)$。

-------------

## P3747 [六省联考 2017] 相逢是问候

依托答辩。

同上题（**P4139 上帝与集合的正确用法**），发现每个位置只会被修改 $\log$ 次，于是先算出最大的修改次数，每次对于还能被修改的暴力到叶子修改就行了。

考虑修改，记：

$$
\left\{
    \begin{array}{l}
        f(x,k,p)=\huge c^{c^{\dots(共k个c)^{a_i}}} \large \pmod{p}\\
        f(x,k)=\huge c^{c^{\dots(共k个c)^{a_i}}}\\
    \end{array}
\right.
$$
则：
$$
f(x,k,p)=
\left\{
    \begin{array}{l}
    	&0 &&p=1\\
    	&x &&k=0\\
    	&c^{f(x,k-1,\phi(p))+[f(x,k-1)\ge\phi(p)]\times \phi(p)} &&otherwise.
    \end{array}
\right.
$$
于是计算的时候顺便返回一下 $f(x,k)$ 是否大于 $p$ 即可。在每一层 $f(x,k,p)$ 里面用快速幂，单次计算是 $O(\log^2P)$ 的，总的时间复杂度是 $O(n(\log n+\log P)\log^2P)$不能通过，发现只有 $O(\log P)$ 层，即只有这么多模数，于是预处理一下光速幂，同时记录下是否大于等于模数就可以了。光速幂可以见 [快速幂 2 LibreOJ](https://loj.ac/p/162)。

-------------------------------

## P1471 方差

线段树上维护一下 $\sum a_i^2$ 和 $\sum a_i$ 就行了。

----------------------

## CF444C DZY Loves Colors

分块。

修改：

- 对于颜色数大于 $1$ 的块，或者修改的边缘的散块，直接暴力重构。因为最多有 $n+m$ 种颜色，因此算上散块也最多重构 $O(n+m)$ 次。
- 对于只有一种颜色的块打 $\text{tag}$。
- 时间复杂度 $O((n+m)(B+\frac{n}{B}))$

查询：

- 对于散块，直接下放 $\text{tag}$ 然后查询。
- 对于中间的块，每个块维护一个 $sum$ 表示每一个块中的权值和，直接查询。
- 时间复杂度 $O(m(B+\frac{n}{B}))$。

$B$ 取 $\sqrt{n}$ 最优，复杂度 $O((n+m)\sqrt{n})$。

--------------

## T404283 三元组统计（triple）

记 $a_{i,j}=a_i-a_j,b,c$ 同理，则题目让计算这个东西：
$$
\sum_{i=1}^n\sum_{j=i+1}^n\max(a_{i,j},b_{i,j},c_{i,j})-\min(a_{i,j},b_{i,j},c_{i,j})\\
= \frac{1}{2}\sum_{i,j\le n,i\not=j}\max(a_{i,j},b_{i,j},c_{i,j})-\min(a_{i,j},b_{i,j},c_{i,j})\\
$$
容易发现，$\max(a,b,c)-\min(a,b,c)=\frac{\max(a,b)-\min(a,b)+\max(a,c)-\min(a,c)+\max(b,c)-\min(b,c)}{2}$，即 最大值+最大值+次大值-最小值-最小值-次小值，等于 最大值+最大值-最小值-最小值。

于是我们只需要计算若干个形如 $\sum_{i,j\le n,i\not=j} \max(a_i-a_j,b_i-b_j)-\min(a_i-a_j,b_i-b_j)$ 的式子。

再次容易发现，当 $a_i-b_i > a_j-b_j$ 的时候，上式等于 $a_i-a_j-b_i+b_j=(a_i-b_i)-(a_j-b_j)$。即 $a_i-b_i$ 的贡献的系数为 $1$ 当且仅当 $a_i-b_i>a_j-b_j$，否则贡献系数为 $-1$。于是将所有的 $a_i-b_i$ 从小到大排序后，第 $i$ 个位置的贡献为 $(i-1-(n-i))=(2i-n-1)$。

时间复杂度 $O(n\log n)$。

-------------------

## MXOI-20231205-A 做题掉坑（[CF Gym104012I](https://codeforces.com/gym/104012/problem/I)）

首先缩掉所有的段，然后转一下将会寄的那一个放在最后一个。接着转化一下，记 $f_i$ 是进行了 $i$ 次操作还没有寄寄的概率，发现寄掉的期望步数 $=\sum_{i=0}f_i$，理由如下：

- 在第 $i$ 次寄掉的概率是 $f_{i-1}-f_i$，而 $\sum_{i=0}f_i=\sum_{i=1} i(f_{i-1}-f_i)$ ，即寄掉的期望步数。

然后这样还是不好算，考虑计算进行 $i$ 次操作还没有寄寄的方案数 $g_i$，则 $f_i=\frac{g_i}{n^i}$。

{% raw %}

设 $G_{i,j}$ 为考虑从第 $i$ 个到第 $m$ 个，选了 $j$ 次还没有寄的方案数，$a_i$ 表示第 $i$ 段的位置数，则：
$$
G_{i,j}=\sum_{k=0}a_i^kG_{i+1,j-k}{{j}\choose{k}}\\
\frac{G_{i,j}}{j!}=\sum_{k=0}\frac{a_{i}^{k}}{k!}\frac{G_{i+1,j-k}}{(j-k)!}
$$
然后是 LRC 快乐时间，考虑 EGF，记 $H_k(x)=\sum_{i=0}^{m-k}\frac{a_k^ix^i}{i!}$，从后往前卷一下就行了，但是注意乘到第 $m-i$ 段的时候，最多选 $i$ 次不会寄奇，所以卷完要把不合法的项的系数赋成 $0$。

记上文卷出来的那个东西是 $O=\sum_{i=0}\frac{o_i}{i!}x^i$，则答案是 $\sum_{i=0}\frac{o_i}{n^i}$。

{% endraw %}

------------------------------

## P8352 [SDOI/SXOI2022] 小 N 的独立集

好 VAN 的 DP 套 DP 题，是 [大哥](https://www.luogu.com.cn/user/1024338) 喜欢的类型。

### 一：超级暴力

最简单的方法就是暴力枚举每个点的权值，然后 DP，设 $g_{u,0/1}$ 分别表示强制不选/不强制不选 $u$ 的时候，$u$ 子树内的最大权独立集，这样单次时间复杂度 $O(n)$，总时间复杂度是 $O(k^nn)$，显然直接原地螺旋爆炸。

### 二：DP 套 DP

DP 套 DP，个人理解就是将内层的 DP 融入进入外层 DP 的下标，比如这道题，可以设 $f_{u,v_0,v_1}$ 表示考虑 $u$ 的子树，$g_{u,0}=v_0,g_{u,1}=v_1$ 时候的方案数，初始为 $f_{u,0,i}=1(1\le i\le k)$。考虑 $x$ 的一个儿子 $y$ 的时候，记 $h_{v0,v1}$ 是不考虑 $y$ 的时候的 $f_{x,v0,v1}$，则转移如下：
$$
f_{x,p0+\max(o0,o1),p1+o0}\leftarrow f_{y,o0,o1}\times h_{p0,p1}
$$
时间复杂度 $O(n^3k^4)$。

### 三：优化 DP 套 DP

考虑上述的 $v0$ 和 $v1$ 一定满足 $v1\ge v0$，且 $v1-v0\le k$，理由显然。于是可以把第三维缩掉，用 $f_{u,p0,p1}$ 表示 $v0=p0,v1=p0+p1$ 时候的方案数。转移如下：
$$
f_{x,p0+o0+o1,\max(p0+o0+o1,p0+p1+o0)}\leftarrow f_{v,o0,o1}\times h_{p0,p1}
$$
时间复杂度 $O(n^2 k^4)$，优化一下常数，就会非常不满，可以通过。

------------------

## P9361 [ICPC2022 Xi'an R] Contests

首先，我们简记为有 $m$ 行，每行一个 $n$ 的排列。其次，答案显然不超过 $n-1$。

发现跳的时候，对于第 $i$ 行一定会跳到最靠前的位置，这样显然是最优的。考虑倍增，记 $f_{k,u,i}$ 表示 $u$ 这个数，跳了至多 $2^k$ 次的时候，在第 $i$ 行的最靠前的位置是什么。预处理是 $O(nm^2\log n)$ 的。

询问的时候倍增就可以了，如果跳 $2^k$ 步的时候，每一行都没有在 $y$ 前面，就让 $x$ 跳这么多步。每次跳是 $O(m^2)$ 的，复杂度 $O(qm^2\log n)$。

别忘了最后统计答案的时候，如果当前的所有位置里面没有 $y$，需要给答案加 $1$（再跳一步）。

感觉贴代码比较适合：

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Slongod{
const int N = 1e5+7 , M = 6 , MX = 18;
int n , m , q , a[M][N] , pos[N][M] , cache[M] , f[MX][N][M];
bool check(int x[] , int y[])
{
    for (int i = 1; i <= m; i++) {
        if (x[i] <= y[i]) {
            return 1;
        }
    } return 0;
}
void init()
{
    memset(f , 0x3f , sizeof(f));
    for (int i = 1; i <= m; i++) {
        memset(cache , 0x3f , sizeof(cache));
        for (int j = n; j >= 1; j--) {
            for (int k = 1; k <= m; k++) {
                cache[k] = min(cache[k] , pos[a[i][j]][k]);
                f[0][a[i][j]][k] = min(f[0][a[i][j]][k] , cache[k]);
            }
        }
    }
    for (int o = 1; o < MX; o++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                for (int k = 1; k <= m; k++) {
                    f[o][i][k] = min(f[o][i][k] , f[o-1][a[j][f[o-1][i][j]]][k]);
                }
            }
        }
    }
}
void move(int x[] , int k)
{
    int tmp[M]; memcpy(tmp , x , sizeof(int[M]));
    memset(x , 0x3f , sizeof(int[M]));
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= m; j++) {
            x[j] = min(x[j] , f[k][a[i][tmp[i]]][j]);
        }
    }
}
bool try_move(int x[] , int y[] , int k)
{
    int tmp[M]; memcpy(tmp , x , sizeof(int[M])); move(x , k);
    if (check(x , y)) {
        memcpy(x , tmp , sizeof(int[M]));
        return 0;
    } else {
        return 1;
    }
}
void main()
{
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> a[i][j]; pos[a[i][j]][i] = j;
        }
    } init();
    cin >> q;
    for (int _i = 1 , x , y , res; _i <= q; _i++) {
        cin >> x >> y; res = 0;
        int now[M]; memcpy(now , pos[x] , sizeof(now));
        if (check(now , pos[y])) {
            cout << 1 << '\n';
        } else {
            for (int i = MX-1; i >= 0; i--) {
                if (try_move(now , pos[y] , i)) {
                    res += (1<<i);
                }
            }
            move(now , 0); res += 2;
            for (int i = 1; i <= m; i++){if (now[i] == pos[y][i]){res--; break;}}
            cout << (res <= n ? res : -1) << '\n';
        }
    }
}
}int main()
{
    ios :: sync_with_stdio(0);
    cin.tie(0) , cout.tie(0);
    return Slongod :: main(),0;
}
```

----------

## P8594 「KDOI-02」一个仇的复

{% raw %}

考虑只用 $y$ 个**横着放的矩形**将 $x$ 列的 $2\times x$ 方格，分成 $j$ 个部分（不能有一个矩形同时存在于任意两个不同的部分）并填满的方案数：
$$
g(x,y,j)={x-1\choose j-1}{2x-2k\choose y-2k}
$$
第一项即枚举每一段的开始位置（第一段一定是 $1$ ，不用枚举），第二项即枚举每一个不是当前段的开始列的矩形的起始位置。

回到题目来计算答案，枚举有几个竖着放的 $2\times 1$ 矩形，再枚举有几个竖着的矩形之间的间隔为空，则答案是：
$$
\sum_{i=0}^{k}\sum_{j=0}^{i}{i+1\choose j}g(n-i,k-i,i+1-j)
$$
时间复杂度 $O(V+k^2)$，取模一定要取干净。

{% endraw %}

--------------

## P1861 星之器

挺好的题，以前没见过。

玩一下样例，容易发现，所有移动的方案最后的答案都是一样的，于是我们只需要找一种简单计算答案的方式。

每一维对答案的贡献都是考虑设一个势能函数来计算，使得移动的势能差等于对答案的贡献，即：
$$
\begin{array}{l}
&f(x+1)+f(y-1)-f(x)-f(y)=y-x-1 &&(x>y)
\end{array}
$$
记 $z=y-1$，可以得到：
$$
f(x)-f(x+1)+x=f(z)-f(z+1)+z
$$
于是我们只需要使得对于任意的 $x$，令 $f(x)-f(x+1)+x$ 为定值就行了。

设 $f(x)=ax^2+bx+c$，可以解得上式等于 $(1-2a)x^2-a-b$，于是我们令 $a=\frac{1}{2}$ 就行了，为了除 $2$ 还是整数，可以令 $f(x)=\frac{x(x-1)}{2}+802x+923$。

然后用初始的势能和减去最终的势能和就是我们的答案。

------------------------

## MXOI-20231205-B 攀比之心([CF Gym 102431G]())

不如原神。

假设已经选出来了一棵包含 $1$ 的树，若 $1$ 在直径的中点上，则无论先手选什么点，后手每一次均能选出一个点 $x$，使得 $x$ 离 $1$ 的距离和 $1$ 离当前点的距离相等，后手必胜；若 $1$ 不在直径的中点上，则相当于后手先动了一下，于是先手必胜。

所以现在要计算所有包含 $1$，且 $1$ 在直径中点上的联通块。设 $mx_u$ 为 $u$ 子树中离 $u$ 最远的点到 $u$ 的距离，$f_{u,k}$ 表示考虑 $u$ 的子树，最远点离 $u$ 为 $k$ 的联通块的方案数，则 $f_{u,0}=1$。长链剖分一下，每次从最深的儿子处继承，然后考虑合并新的儿子。记 $tmp_k$ 为不含新的儿子的 $f_{u,k}$，转移如下：
$$
f_{u,k}=tmp_k+tmp_k\sum_{j=0}^{k-1} f_{v,j}+\sum_{j=0}^{k-1}tmp_jf_{v,k-1}
$$
直接转移是 $O(n^3)$ 的，前缀和优化是 $O(n^2)$ 的（因为要枚举长链的长度次，所以长链剖分如剖）。容易发现每次只枚举短链的长度，因为对于 $k>mx_v+1$ 的 $k$，从 $v$ 合并的贡献都是一样的，所以打个 $tag$ 然后维护一下，时间复杂度是 $O(n)$ 的。

在根处统计答案，设 $g_{0/1,k}$ 表示有选出了 $1$ 个/多个 子树离 $1$ 最远点为 $k$ 的联通块的方案数，初始 $h_{1,0}=1$，考虑合并子树 $v$，记 $tmp_{0/1,k}$ 为不含新的儿子的 $g_{0/1,k}$，转移如下：
$$
g_{1,k}=tmp_{1,k}+tmp_{1,k}\sum_{j=0}^{k-1}f_{v,j}+tmp_{0,k}f_{v,k-1}\\
g_{0,k}=tmp_{0,k}+tmp_{0,k}\sum_{j=0}^{k-2}f_{v,j}+\sum_{j=0}^{k-1}(tmp_{0,j}+tmp_{1,j})f_{v,k-1}
$$
同样维护一些 $tag$ 就行了。然后就做完了，最后的答案是 $\sum_i g_{1,i}$，时间复杂度 $O(n)$，~~晚上再写~~（写完了，低达 4.7K）。

------------------------------------------

## CF103E Buying Sets

双倍经验：[LOJ #6045. 「雅礼集训 2017 Day8」价](https://loj.ac/p/6045)

将所有集合的权值取反，变成选最大权值，下文的所有讨论均基于此基础。

先不考虑选的集合和选的数数量相等，这就是一个朴素的最大权闭合子图问题，直接网络流，跑最小割就可以了。

为了满足数量相等的限制，我们可以给每一个集合的权值加上 $lim$，给选每一个数的代价也设为 $lim$，其中 $lim$ 是一个特别大的数。记集合 $i$ 的原权值为 $x_i$。将集合放在左部点，对于集合 $i$，连一条边 $S\rightarrow i$，权值是 $lim+x_i$；将数放在右部点，对于数 $i$，连一条边 $i\rightarrow T$，权值是 $lim$；集合和对应的点之间连边权为 $\infty$ 的边。最后割完之后，若集合/数与 $S$ 在一起，代表选，否则代表不选。由于选的集合的数量 $\le$ 选的数的数量（题目保证），即 不选的集合数量+选的数的数量 $\ge n$，所以求的最小割一定满足 不选的集合数量 $+$ 选的数的数量 $=n$，即选的集合数量 $=$ 选的数的数量。

时间复杂度为 Dinic 的复杂度，但远底于 $O(n^4)$ 的上界。
