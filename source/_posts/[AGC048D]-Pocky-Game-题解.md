## 题意

给你 $n$ 堆石子，甲先手，乙后手。甲每次可以从最左边非空的石子堆中取任意个，乙每次可以从最右边非空的石子堆中取任意个，不能取的人输。问甲是否有必胜策略。

## 题解

先说明两点性质：

> 性质 $1$：当其它堆的石子固定的时候，当前（最左或最右）堆的石子越多，情况对于当前的先手越有利。

证明：因为可以取任意多个石子，所以对于当前先手来说，石子多不会使得情况变劣，且石子少能到达的所有状态石子多的时候也都能达到，石子多能到达的状态石子少的时候不一定能达到。

> 性质 $2$：当前的先手只可能取 $1$ 个或全取完。

证明：若只剩一堆，则取完当前石子堆，后手必败，一定会取完。因此，当不需要取完当前石子堆的时候，至少还剩下两堆石子，根据上述性质 $1$，令当前剩的石子越多越好，于是当前先手只取 $1$ 个。

有了这两条性质，我们就好办许多了，我们可以设立以下状态：

- 设 $f_{l,r}$ 代表 $[l+1,r]$ 堆中的石子个数**确定**为题目给出的石子个数，且轮到甲操作时，当前堆 $l$ **至少**需要多少才能使得**甲必胜**。
- 设 $g_{l,r}$ 代表 $[l,r-1]$ 堆中的狮子个数**确定**为题目给出的石子个数，且轮到乙操作时，当前堆 $r$ **至少**需要多少才能使得**乙必胜**。

我们考虑 $f$ 的转移：

- 当 $a_r<g_{l+1,r}$ 时，只要当前堆非空，取完即可使得**甲必胜**，于是 $f_{l,r}=1$。
- 当 $a_r\ge g_{l+1,r}$ 时，双方会轮流取一个（即甲选择 $a_l$ 减少 $1$，乙选择 $a_r$ 减少 $1$），直到 $a_{l}<f_{l,r-1}$（乙胜）或 $a_r<g_{l+1,r}$（甲胜）。因此，甲想要获胜，首先不能被拖入 $a_l=0$ 且 $a_r\ge g_{l+1,r}$ 的境地，并且还要保证在拖赢乙之前时刻满足 $a_l\ge f_{l,r-1}$（否则乙就会全取完而获胜），因此可得 $f_{l,r}=a_r-g_{l+1,r}+1+f_{l,r-1}$。

即：
$$
f_{l,r}=
\left\{
\begin{aligned}
&1 &&(a_r<g_{l+1,r})\\
&a_r-g_{l+1,r}+1+f_{l,r-1} &&(a_r\ge g_{l+1,r})
\end{aligned}
\right.
$$
同理可得：
$$
g_{l,r}=
\left\{
\begin{aligned}
&1 &&(a_l<f_{l,r-1})\\
&a_{l}-a_{l,r-1}+1+g_{l+1,r} &&(a_l\ge f_{l,r-1})\\
\end{aligned}
\right.
$$
于是 $O(n^2)$ 递推即可，代码简单。

```cpp
void main()
{
    int T; cin >> T;
    while(T--) {
        cin >> n;
        for (int i = 1; i <= n; i++){cin >> a[i];}
        for (int i = 1; i <= n; i++){f[i][i] = g[i][i] = 1;}
        for (int k = 2; k <= n; k++) {
            for (int i = 1 , j = i + k - 1; i <= n; i++ , j++) {
                if (a[j] < g[i+1][j]){f[i][j] = 1;}
                else{f[i][j] = a[j] - g[i+1][j] + 1 + f[i][j-1];}
                if (a[i] < f[i][j-1]){g[i][j] = 1;}
                else{g[i][j] = a[i] - f[i][j-1] + 1 + g[i+1][j];}
            }
        } cout << (f[1][n] <= a[1] ? "First\n" : "Second\n");
    }
}
```

